---
name: manage-skills
description: 세션 변경사항을 분석하여 검증 스킬 누락을 탐지합니다. 사용자 입력(코딩 스탠다드, 패턴, 규칙)과 AI 세션 분석을 모두 지원합니다. 파일시스템 동적 탐색으로 기존 스킬을 발견하고, 새 스킬을 생성하거나 기존 스킬을 업데이트한 뒤 CLAUDE.md를 관리합니다.
allowed-tools: Read, Write, Edit, Grep, Glob, Bash
argument-hint: "[선택사항: 코딩 스탠다드, 패턴, 또는 규칙]"
---

# Manage Skills

세션 기반 스킬 유지보수 시스템. 코드 변경사항과 세션 히스토리를 분석하여 verify-* 검증 스킬의 누락을 탐지하고, 새 스킬을 생성하거나 기존 스킬을 업데이트합니다.

**입력**: $ARGUMENTS

---

## Workflow

### Step 1. 입력 분석

$ARGUMENTS 의 내용을 확인하여 입력 모드를 결정합니다.

**명시적 입력 모드** — $ARGUMENTS 에 코딩 스탠다드, 패턴, 규칙 등 구체적인 내용이 있는 경우:
- 해당 내용을 스킬 생성/업데이트의 **주요 소스**로 사용
- 사용자가 "이 패턴을 스킬로 만들어줘", "이 규칙을 추가해줘" 등 명시적 지시를 한 경우
- 이 경우에도 Step 2 세션 분석은 **추가로** 실행하여 보완 가능

**세션 분석 모드** — $ARGUMENTS 가 비어있거나 "저장해야 될 요소들을 추려달라" 같은 일반적 요청인 경우:
- Step 2로 진행하여 세션 히스토리에서 스킬화할 요소를 자동 추출
- 대화 중 반복된 교정, 새로 확립된 컨벤션, API 형태 변경 등을 분석

**우선순위**: 명시적 입력이 있으면 최우선 처리하되, 세션 분석 결과도 함께 반영합니다.

---

### Step 2. 세션 히스토리 분석

#### 2a. 변경 파일 수집

```bash
# 최근 커밋 기준 변경 파일 확인
git diff --name-only HEAD~1..HEAD

# WF 런 실행 중이면 worklog에서 변경 파일 범위 확인
# .work/ 하위에 활성 런 디렉토리가 있는지 확인
```

- `git diff --name-only` 로 변경/생성된 파일 목록 수집
- WF 런 중이라면 worklog.md 에서 기록된 변경 범위도 참조
- 변경된 파일의 유형 (소스코드, 설정, 문서, 스킬 파일 등) 분류

#### 2b. 세션 컨텍스트 분석

대화 히스토리를 분석하여 다음 패턴들을 추출합니다:

- **새로 확립된 컨벤션**: 세션 중 정해진 코딩 규칙, 네이밍 규칙, 파일 구조 등
- **반복된 교정 패턴**: 사용자가 같은 유형의 수정을 여러 번 요청한 경우
- **새로운 API 형태**: 새로 도입되거나 변경된 API 구조, 데이터 모델
- **파일 구조 변경**: 디렉토리 구조 변경, 새로운 파일 배치 규칙
- **코드 패턴**: 에러 처리 방식, 상태 관리 패턴, 컴포넌트 구조 등

#### 2c. 스킬 후보 추출

위 분석에서 **저장할 가치가 있는 요소**들을 추출합니다:

```
추출 기준:
- 한 번 이상 반복된 패턴 -> 스킬 후보
- 명시적으로 "이렇게 해야 한다"고 확립된 규칙 -> 스킬 후보
- 프로젝트 전반에 적용되는 구조적 결정 -> 스킬 후보
- 일회성 수정, 특정 파일에만 해당하는 변경 -> 제외
```

추출된 후보 목록을 사용자에게 제시합니다:

```
## 스킬 후보 분석 결과

1. [후보명] — [설명] (출처: 세션 분석 / 사용자 입력)
2. [후보명] — [설명] (출처: 세션 분석 / 사용자 입력)
...
```

---

### Step 3. verify-* 스킬 탐색 및 매핑

#### 3a. 기존 스킬 탐색

파일시스템을 스캔하여 현재 존재하는 verify-* 스킬을 동적으로 탐색합니다. 파일시스템이 레지스트리 역할을 합니다. 별도의 테이블 동기화는 불필요합니다.

```bash
# Primary: 소비 프로젝트의 .claude/skills/ 디렉토리
ls -d .claude/skills/verify-*/ 2>/dev/null

# Fallback: 플러그인 내부 skills/ 디렉토리
ls -d skills/verify-*/ 2>/dev/null
```

- `.claude/skills/verify-*/SKILL.md` 패턴을 우선 탐색하고, `skills/verify-*/SKILL.md` 를 폴백으로 수집
- 각 스킬의 대상 파일 패턴과 검증 범위를 파악

#### 3b. 변경 파일 매핑

변경된 파일들을 기존 verify-* 스킬의 파일 패턴에 매핑합니다:

```
[변경 파일] -> [매핑된 verify-* 스킬] 또는 [미매핑]
```

---

### Step 4. 커버리지 갭 분석

#### 4a. 미커버 파일 식별

변경된 파일 중 어떤 verify-* 스킬에도 매핑되지 않는 파일을 식별합니다.

#### 4b. 미커버 패턴 식별

Step 1 (사용자 입력) 및 Step 2 (세션 분석)에서 추출된 패턴/규칙 중 현재 어떤 verify-* 스킬에서도 검증하지 않는 항목을 식별합니다.

#### 4c. 제외 대상

다음 스킬은 참조/가이드라인 스킬이므로 verify-* 관리 대상에서 **명시적으로 제외**합니다:

- `web-design-guidelines` — UI 리뷰 가이드라인 (참조용)
- `vercel-react-best-practices` — React/Next.js 성능 가이드라인 (참조용)
- `frontend-design` — 프론트엔드 디자인 가이드라인 (참조용)

이 스킬들은 검증 대상이 아니며, 갭 분석에서 제외됩니다.

#### 4d. 갭 리포트

```
## 커버리지 갭 분석 결과

### 미커버 파일
- [파일 경로] — 해당 verify-* 스킬 없음

### 미커버 패턴/규칙
- [패턴명] — 현재 검증 스킬에서 다루지 않는 영역

### 커버리지 요약
- 변경 파일 수: N
- 커버된 파일: N (N%)
- 미커버 파일: N (N%)
```

---

### Step 5. CREATE vs UPDATE 자동 결정

각 스킬 후보와 커버리지 갭에 대해 자동으로 액션을 결정합니다.

#### 결정 로직

```
IF 기존 verify-* 스킬이 해당 영역을 커버하지만 패턴 확장 필요:
  -> UPDATE (기존 스킬에 규칙/패턴 추가)

IF 해당 영역을 커버하는 verify-* 스킬이 없음:
  -> CREATE (새 verify-* 스킬 생성)

IF 기존 스킬이 이미 완전히 커버:
  -> SKIP (추가 작업 불필요)
```

#### 판단 기준

- **파일 패턴 중첩**: 기존 스킬의 대상 파일 패턴과 새 패턴의 겹침 정도
- **의미적 유사성**: 기존 스킬의 검증 규칙과 새 규칙의 관련성
- **범위 적정성**: 하나의 스킬이 너무 많은 영역을 커버하지 않도록 분리

#### 결정 결과 제시

사용자에게 결정 사항을 제시하고 확인을 받습니다:

```
## 액션 플랜

| # | 액션 | 대상 스킬 | 사유 |
|---|------|-----------|------|
| 1 | CREATE | verify-<name> | [사유] |
| 2 | UPDATE | verify-<name> | [사유] |
| 3 | SKIP | verify-<name> | [사유] |

진행하시겠습니까?
```

**사용자 확인 후 Step 6, 7을 실행합니다.**

---

### Step 6. 기존 스킬 업데이트

UPDATE 로 결정된 스킬에 대해 기존 SKILL.md 를 수정합니다.

#### 업데이트 원칙

- 기존 Workflow 스텝은 **보존** — 새 스텝은 필요 시 추가
- 파일 패턴이 확장된 경우 frontmatter 또는 본문에 반영
- 기존 검증 규칙과 충돌하지 않도록 주의
- Exceptions 섹션에 새 예외사항 반영 (필요 시)

#### 변경 방법

```
Edit 도구를 사용하여 최소한의 변경만 적용:
- 새 검증 규칙 추가
- 파일 패턴 확장
- Exceptions 업데이트
```

---

### Step 7. 새 스킬 생성

CREATE 로 결정된 스킬에 대해 새 SKILL.md 를 생성합니다.

#### 스킬 파일 위치

소비 프로젝트의 `.claude/skills/` 디렉토리에 생성합니다 (플러그인 내부가 아님):

```
.claude/skills/verify-<name>/SKILL.md
```

#### 템플릿 구조

```markdown
---
name: verify-<name>
description: [한국어 설명]
allowed-tools: Read, Grep, Glob, Bash
---

# Verify <Name>

[스킬 설명]

## Workflow

### Step 1. [검증 단계]
[구체적인 검증 로직]

### Step 2. [검증 단계]
[구체적인 검증 로직]

...

## 대상 파일 패턴

- `[glob 패턴]` — [설명]

## Exceptions

- [예외 사항]
```

#### 생성 규칙

- 각 verify-* 스킬은 반드시 포함: Workflow 스텝, 대상 파일 패턴, Exceptions
- frontmatter: name, description, allowed-tools (Read, Grep, Glob, Bash)
- 검증 로직은 구체적이고 자동화 가능해야 함
- 한 스킬이 너무 많은 영역을 커버하지 않도록 적절히 분리

---

### Step 8. 검증 및 리포트

#### 8a. 파일 유효성 검증

생성/업데이트된 모든 SKILL.md 파일이 올바른지 확인합니다:

- frontmatter 가 유효한 YAML 형식인지 (name, description, allowed-tools 필수)
- 파일 경로가 `.claude/skills/` 디렉토리 규칙을 따르는지
- Workflow 섹션이 존재하는지

#### 8b. CLAUDE.md 업데이트

CLAUDE.md 에 스킬 관련 섹션(테이블 등)이 존재하면 최신 상태로 업데이트합니다.

#### 8c. 결과 리포트 출력

```
## 스킬 관리 결과

### 생성된 스킬
- verify-<name>: [설명]

### 업데이트된 스킬
- verify-<name>: [변경 내용]

### 커버리지 변화
- Before: N개 파일 패턴 커버
- After: N개 파일 패턴 커버
- 개선율: +N%

### 잔여 갭
- [갭이 있다면 기재, 없으면 "없음"]
```

---

## Quality Criteria

- 모든 verify-* 스킬은 구체적이고 자동화 가능한 검증 규칙을 포함해야 합니다
- 스킬 간 중복 검증이 없어야 합니다 (하나의 규칙은 하나의 스킬에서만)
- 파일 패턴은 glob 형식으로 명확해야 합니다
- Exceptions 은 의도적인 예외만 포함해야 합니다
- 참조/가이드라인 스킬은 절대 verify-* 관리 대상에 포함하지 않습니다

## Related Files

- `.claude/skills/verify-*/SKILL.md` — 개별 검증 스킬 파일 (소비 프로젝트, primary)
- `skills/verify-*/SKILL.md` — 개별 검증 스킬 파일 (플러그인 내부, fallback)
- `skills/verify-implementation/SKILL.md` — 모든 verify-* 스킬 병렬 실행기
- `skills/wf/SKILL.md` — WF 파이프라인 (Phase 4에서 본 스킬 호출)
- `CLAUDE.md` — 프로젝트 루트 설정 파일 (스킬 목록 관리)

## Exceptions

- `web-design-guidelines`, `vercel-react-best-practices`, `frontend-design` 스킬은 참조/가이드라인 용도이므로 관리 대상에서 제외
- `wf` 스킬은 파이프라인 오케스트레이터이므로 verify-* 관리 대상에서 제외
- `manage-skills` (본 스킬) 자체는 관리 대상에서 제외
- `verify-implementation` 은 실행기이므로 verify-* 검증 스킬 목록에 포함하지 않음
